package org.haywired.firefly.wiki;
/* Generated By:JavaCC: Do not edit this line. Translator.java */
import java.io.*;
import java.util.Hashtable;
import java.applet.Applet;

// Copyright (c) 1998, Ward Cunningham
// All Rights Reserved

public class Translator extends Applet implements TranslatorConstants {
         public static PrintStream out = System.out;
         public static String script = "wiki";
         public static Hashtable pages = new Hashtable();

         public Translator() {
         }

         public static void main(String args[]) throws ParseException {

                 // sample definitions
                 pages.put("JavaWiki", "A servlet implementation of wiki.");
                 pages.put("WardCunningham", "See http://c2.com/~ward.");

                 // caller writes header and footer
                 out.print("<body bgcolor=#ffffff>\r\n");
                 out.print("<h1><image src=logo.gif> Sample Page</h1>\r\n");

                 // run the translator; call ReInit(System.in) if reused.
                 Translator parser = new Translator(System.in);
                 parser.Page();
         }

         static void page (String s) {
                 //if (pages.containsKey(s)) {
                 //        out.print("<a href=\"" + script + "?" + s + "\">" + s + "</a>");
                 //} else {
                 //        out.print(s + "<a href=\"" + script + "?edit=" + s + "\">?</a>");
                 //}
                 // sjeh:
                 out.print(s);
         }

         static void link (String s) {
                 if (s.endsWith(".gif") || s.endsWith(".jpg")) {
                         out.print("<img src=\"" + s + "\">");
                 } else {
                         out.print("<a href=\"external.jsp?" + s + "\">" + s + "</a>");
                 }
         }

         static void book (String s) {
                 char c[] = s.toCharArray();
                 StringBuffer b = new StringBuffer();
                 for (int i=0; i<c.length; i++) {
                         if (Character.isDigit(c[i]) || c[i] == 'X') {
                                 b.append(c[i]);
                         }
                 }
                 out.print("<a href=\"http://www.amazon.co.uk/exec/obidos/ISBN=" +
                         b.toString() +  "\">" + s + "</a>");
         }

  static final public void Page() throws ParseException {
    label_1:
    while (true) {
      if (jj_mask_0[getToken(1).kind]) {
        ;
      } else {
        jj_expLA1[0] = jj_gen;
        break label_1;
      }
      if (jj_mask_4[getToken(1).kind]) {
        Spacing();
      } else {
        jj_expLA1[4] = jj_gen;
        if (jj_mask_3[getToken(1).kind]) {
          Emphasis();
        } else {
          jj_expLA1[3] = jj_gen;
          if (jj_mask_2[getToken(1).kind]) {
            Links();
          } else {
            jj_expLA1[2] = jj_gen;
            if (jj_mask_1[getToken(1).kind]) {
              Text();
            } else {
              jj_expLA1[1] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
    jj_consume_token(0);
  }

  static boolean[] jj_mask_0 = new boolean[18];
  static {
    jj_mask_0[1] =
    jj_mask_0[2] =
    jj_mask_0[3] =
    jj_mask_0[4] =
    jj_mask_0[5] =
    jj_mask_0[6] =
    jj_mask_0[PAGE] =
    jj_mask_0[LINK] =
    jj_mask_0[BOOK] =
    jj_mask_0[EOL] =
    jj_mask_0[OTHER] =
    jj_mask_0[BLANK] =
    jj_mask_0[SPACE] =
    jj_mask_0[TAB] =
    jj_mask_0[RULE] =
    jj_mask_0[BULLET] = true;
  }
  static boolean[] jj_mask_1 = new boolean[18];
  static {
    jj_mask_1[3] =
    jj_mask_1[4] =
    jj_mask_1[5] =
    jj_mask_1[6] =
    jj_mask_1[OTHER] = true;
  }
  static boolean[] jj_mask_2 = new boolean[18];
  static {
    jj_mask_2[PAGE] =
    jj_mask_2[LINK] =
    jj_mask_2[BOOK] = true;
  }
  static boolean[] jj_mask_3 = new boolean[18];
  static {
    jj_mask_3[1] =
    jj_mask_3[2] = true;
  }
  static boolean[] jj_mask_4 = new boolean[18];
  static {
    jj_mask_4[EOL] =
    jj_mask_4[BLANK] =
    jj_mask_4[SPACE] =
    jj_mask_4[TAB] =
    jj_mask_4[RULE] =
    jj_mask_4[BULLET] = true;
  }
  
  static final public void Spacing() throws ParseException {
 Token t;
    if (jj_mask_10[getToken(1).kind]) {
      jj_consume_token(EOL);
         out.print("\r\n");
    } else {
      jj_expLA1[10] = jj_gen;
      if (jj_mask_9[getToken(1).kind]) {
        jj_consume_token(BLANK);
           out.print("<p>");
      } else {
        jj_expLA1[9] = jj_gen;
        if (jj_mask_8[getToken(1).kind]) {
          jj_consume_token(BULLET);
            out.print("<li>");
        } else {
          jj_expLA1[8] = jj_gen;
          if (jj_mask_7[getToken(1).kind]) {
            jj_consume_token(RULE);
          out.print("<hr>");
          } else {
            jj_expLA1[7] = jj_gen;
            if (jj_mask_6[getToken(1).kind]) {
              Indent("<br>");
              label_2:
              while (true) {
                if (jj_mask_5[getToken(1).kind]) {
                  ;
                } else {
                  jj_expLA1[5] = jj_gen;
                  break label_2;
                }
                Indent("");
              }
            } else {
              jj_expLA1[6] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
  }

  static boolean[] jj_mask_5 = new boolean[18];
  static {
    jj_mask_5[SPACE] =
    jj_mask_5[TAB] = true;
  }
  static boolean[] jj_mask_6 = new boolean[18];
  static {
    jj_mask_6[SPACE] =
    jj_mask_6[TAB] = true;
  }
  static boolean[] jj_mask_7 = new boolean[18];
  static {
    jj_mask_7[RULE] = true;
  }
  static boolean[] jj_mask_8 = new boolean[18];
  static {
    jj_mask_8[BULLET] = true;
  }
  static boolean[] jj_mask_9 = new boolean[18];
  static {
    jj_mask_9[BLANK] = true;
  }
  static boolean[] jj_mask_10 = new boolean[18];
  static {
    jj_mask_10[EOL] = true;
  }
  
  static final public void Indent(String s) throws ParseException {
    if (jj_mask_12[getToken(1).kind]) {
      jj_consume_token(SPACE);
           out.print(s); out.print("&nbsp;");
    } else {
      jj_expLA1[12] = jj_gen;
      if (jj_mask_11[getToken(1).kind]) {
        jj_consume_token(TAB);
         out.print(s); out.print("&nbsp;&nbsp;&nbsp;&nbsp;");
      } else {
        jj_expLA1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static boolean[] jj_mask_11 = new boolean[18];
  static {
    jj_mask_11[TAB] = true;
  }
  static boolean[] jj_mask_12 = new boolean[18];
  static {
    jj_mask_12[SPACE] = true;
  }
  
  static final public void Emphasis() throws ParseException {
    if (jj_mask_20[getToken(1).kind]) {
      jj_consume_token(1);
         out.print("<i>");
      label_4:
      while (true) {
        if (jj_mask_17[getToken(1).kind]) {
          ;
        } else {
          jj_expLA1[17] = jj_gen;
          break label_4;
        }
        if (jj_mask_19[getToken(1).kind]) {
          Links();
        } else {
          jj_expLA1[19] = jj_gen;
          if (jj_mask_18[getToken(1).kind]) {
            Text();
          } else {
            jj_expLA1[18] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      jj_consume_token(1);
                                                         out.print("</i>");
    } else {
      jj_expLA1[20] = jj_gen;
      if (jj_mask_16[getToken(1).kind]) {
        jj_consume_token(2);
         out.print("<b>");
        label_3:
        while (true) {
          if (jj_mask_13[getToken(1).kind]) {
            ;
          } else {
            jj_expLA1[13] = jj_gen;
            break label_3;
          }
          if (jj_mask_15[getToken(1).kind]) {
            Links();
          } else {
            jj_expLA1[15] = jj_gen;
            if (jj_mask_14[getToken(1).kind]) {
              Text();
            } else {
              jj_expLA1[14] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
        jj_consume_token(2);
                                                         out.print("</b>");
      } else {
        jj_expLA1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static boolean[] jj_mask_13 = new boolean[18];
  static {
    jj_mask_13[3] =
    jj_mask_13[4] =
    jj_mask_13[5] =
    jj_mask_13[6] =
    jj_mask_13[PAGE] =
    jj_mask_13[LINK] =
    jj_mask_13[BOOK] =
    jj_mask_13[OTHER] = true;
  }
  static boolean[] jj_mask_14 = new boolean[18];
  static {
    jj_mask_14[3] =
    jj_mask_14[4] =
    jj_mask_14[5] =
    jj_mask_14[6] =
    jj_mask_14[OTHER] = true;
  }
  static boolean[] jj_mask_15 = new boolean[18];
  static {
    jj_mask_15[PAGE] =
    jj_mask_15[LINK] =
    jj_mask_15[BOOK] = true;
  }
  static boolean[] jj_mask_16 = new boolean[18];
  static {
    jj_mask_16[2] = true;
  }
  static boolean[] jj_mask_17 = new boolean[18];
  static {
    jj_mask_17[3] =
    jj_mask_17[4] =
    jj_mask_17[5] =
    jj_mask_17[6] =
    jj_mask_17[PAGE] =
    jj_mask_17[LINK] =
    jj_mask_17[BOOK] =
    jj_mask_17[OTHER] = true;
  }
  static boolean[] jj_mask_18 = new boolean[18];
  static {
    jj_mask_18[3] =
    jj_mask_18[4] =
    jj_mask_18[5] =
    jj_mask_18[6] =
    jj_mask_18[OTHER] = true;
  }
  static boolean[] jj_mask_19 = new boolean[18];
  static {
    jj_mask_19[PAGE] =
    jj_mask_19[LINK] =
    jj_mask_19[BOOK] = true;
  }
  static boolean[] jj_mask_20 = new boolean[18];
  static {
    jj_mask_20[1] = true;
  }
  
  static final public void Links() throws ParseException {
  Token t;
    if (jj_mask_23[getToken(1).kind]) {
      t = jj_consume_token(PAGE);
            page(t.image);
    } else {
      jj_expLA1[23] = jj_gen;
      if (jj_mask_22[getToken(1).kind]) {
        t = jj_consume_token(LINK);
            link(t.image);
      } else {
        jj_expLA1[22] = jj_gen;
        if (jj_mask_21[getToken(1).kind]) {
          t = jj_consume_token(BOOK);
            book(t.image);
        } else {
          jj_expLA1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  static boolean[] jj_mask_21 = new boolean[18];
  static {
    jj_mask_21[BOOK] = true;
  }
  static boolean[] jj_mask_22 = new boolean[18];
  static {
    jj_mask_22[LINK] = true;
  }
  static boolean[] jj_mask_23 = new boolean[18];
  static {
    jj_mask_23[PAGE] = true;
  }
  
  static final public void Text() throws ParseException {
  Token t;
    if (jj_mask_28[getToken(1).kind]) {
      jj_consume_token(3);
        out.print("&amp;");
    } else {
      jj_expLA1[28] = jj_gen;
      if (jj_mask_27[getToken(1).kind]) {
        jj_consume_token(4);
        out.print("&lt;");
      } else {
        jj_expLA1[27] = jj_gen;
        if (jj_mask_26[getToken(1).kind]) {
          jj_consume_token(5);
        out.print("&gt;");
        } else {
          jj_expLA1[26] = jj_gen;
          if (jj_mask_25[getToken(1).kind]) {
            jj_consume_token(6);
        out.print("&quot;");
          } else {
            jj_expLA1[25] = jj_gen;
            if (jj_mask_24[getToken(1).kind]) {
              t = jj_consume_token(OTHER);
             out.print(t.image);
            } else {
              jj_expLA1[24] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
  }

  static boolean[] jj_mask_24 = new boolean[18];
  static {
    jj_mask_24[OTHER] = true;
  }
  static boolean[] jj_mask_25 = new boolean[18];
  static {
    jj_mask_25[6] = true;
  }
  static boolean[] jj_mask_26 = new boolean[18];
  static {
    jj_mask_26[5] = true;
  }
  static boolean[] jj_mask_27 = new boolean[18];
  static {
    jj_mask_27[4] = true;
  }
  static boolean[] jj_mask_28 = new boolean[18];
  static {
    jj_mask_28[3] = true;
  }
  
  static private boolean jj_initialized_once = false;
  static public TranslatorTokenManager token_source;
  static ASCII_CharStream jj_input_stream;
  static public Token token;
  static private int jj_gen;
  static private int[] jj_expLA1 = new int[29];

  public Translator(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new TranslatorTokenManager(jj_input_stream);
    token = new Token();
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_expLA1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_expLA1[i] = -1;
  }

  public Translator(TranslatorTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_expLA1[i] = -1;
  }

  public void ReInit(TranslatorTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_expLA1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[18];
    boolean[] mask = null;
    for (int i = 0; i < 18; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_expLA1[i] == jj_gen) {
        switch (i) {
          case 0: mask = jj_mask_0; break;
          case 1: mask = jj_mask_1; break;
          case 2: mask = jj_mask_2; break;
          case 3: mask = jj_mask_3; break;
          case 4: mask = jj_mask_4; break;
          case 5: mask = jj_mask_5; break;
          case 6: mask = jj_mask_6; break;
          case 7: mask = jj_mask_7; break;
          case 8: mask = jj_mask_8; break;
          case 9: mask = jj_mask_9; break;
          case 10: mask = jj_mask_10; break;
          case 11: mask = jj_mask_11; break;
          case 12: mask = jj_mask_12; break;
          case 13: mask = jj_mask_13; break;
          case 14: mask = jj_mask_14; break;
          case 15: mask = jj_mask_15; break;
          case 16: mask = jj_mask_16; break;
          case 17: mask = jj_mask_17; break;
          case 18: mask = jj_mask_18; break;
          case 19: mask = jj_mask_19; break;
          case 20: mask = jj_mask_20; break;
          case 21: mask = jj_mask_21; break;
          case 22: mask = jj_mask_22; break;
          case 23: mask = jj_mask_23; break;
          case 24: mask = jj_mask_24; break;
          case 25: mask = jj_mask_25; break;
          case 26: mask = jj_mask_26; break;
          case 27: mask = jj_mask_27; break;
          case 28: mask = jj_mask_28; break;
        }
        for (int j = 0; j < 18; j++) {
          if (mask[j]) la1tokens[j] = true;
        }
      }
    }
    for (int i = 0; i < 18; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
